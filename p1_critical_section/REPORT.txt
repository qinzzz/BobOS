
- Explain what all the files in the kernel directory do:
    - what abstractions does it introduce (if it does) software
    - what resources does it manage (if it does) hardware

    - atomic.h:
    Define atomic and atomicPtr classes using built-in '__atomic' functions. 
    It introduces the abstraction of atomic operation, which is an operation that can be excuted without other processors running.

    - config.cc & config.h:
    Discover the configuration of the system, like memory size, number of processors, and infomation about APIC.
    It introduces the abstraction and manages the resource of SDT(System Description Table), APIC(Advanced Programmable Interrupt Controller), 
    MADT(Multiple APIC Description Table), and RSD(Root System Descriptior).

    - critical.cc & critical.h:
    It introduces abstractions for the entry and exit of a critical section. Those functions help to protect a critical section from concurrent access.

    - debug.cc & debug.h:
    Define a class Debug, which provides some functions for debugging, like to print results, report kernel panics and shutdown cores.
    It introduces the abstraction of debug functions.

    - idt.cc & idt.h:
    It introduce the abstraction of an Interrupt Descriptor Table, including the interrupt gate and trap gate.
    It also manage the resourec of IDT.

    - init.cc & init.h: 
    Initialize the kernel.
    It manages the resource of a UART, discover the configuration of system, start all the processors, and call kernelMain() to run tests.

    - io.h:
    It introduces the abstraction of inputstream and outputstream.

    - kernel.cc & kernel.h:
    It is an symbolic linked to the test case that contains kernelMain();
    It is an abstraction of OS kernel.

    - libk.cc & libk.h:
    It introduces the abstraction of namespace K that use formatted snprintf to print strings.

    - machine.S && machine.h:
    Define basic funcitons to write/read data from I/O ports and MSRs.
    It manages the resource of machine's I/O ports.

    - Makefile:
    It includes the commands to compile and link our program.

    - mbr.S:
    The bootstrp code for the kernel.  
    It introduce the abstraction of Task State Segment (TSS) and Global Descriptor Table (GDT).
    It manages the resource of MBR, a bootsector of a hard disk.

    - script.ld:
    It decribes that MBR will be compiled at 0x7c00, and the kernel will be loaded at 0x8000.

    - smp.cc & smp.h:
    SMP -- Symmetric multiprocessing. 
    It involves a multiprocessor computer hardware and software architecture where several identical processors are connected to a single, shared main memory.
    It manages the resource of a symmetric multiprocessing and also one single CPU.

    - snprintf.cc & snprintf.h:
    snprintf is a function to write formatted strings to character string buffer. Unlike sprintf, it checks limit for string length.
    It introduced the abstraction of print functions that write formatted strings and limit string length.

    - stdint.h:
    Define standard int types used in this program.
    It introduces the abstration of different interger types.

    - u8250.cc & u8250.h: 
    8250 UART -- Universal Asynchronous Receiver/Transmitter is a chip for asynchronous serical communication.
    It manages the resource of 8250 UART chip.


- What is the MBR?

MBR refers to Master Boot Record, it is the first 512 Bytes in the first sector of the disk. 
MBR contains bootstrap code and partition table, which helps the operating system to boot and find four primary partitions of the disk.[1]
When BIOS looks for MBR, it looks at the last 2 Bytes of sector0: if they are 0xff 0xaa, then this sector contains MBR.

- Explain the relationship between kernel/kernel.cc and t0.cc?

kernel/kernel.cc is a file linked to t0.cc. When we run the code, we are running function kernelMain() in kernel.cc instead of <test case>.cc.
Makefile contains 'ln -s ../$*.cc kernel.cc', which creates a link from <test case>.cc to kernel/kernel.cc.
So everytime we run different test cases, the program only needs to call the same function kernelMain() in kernel.cc.

- Look at the output from running "make clean all" and try to classify the
  commands that it issues (gcc, ld, dd, rm, ...). For each of them:

     * explain what it does
     * explain the different command line arguments generated by the Makefile

     Limit your explanation to one line for command and each argument.

     For example:

        - rm: removes one or more files or directories
        - "-r": do it recursively

rm -rf *.diff *.raw *.out *.result
rm -f *.img
    - rm: remove one or more files or directories
    - "-f": remove the files or directories and ignore nonexistent files
    - "-rf": remove the files or directories recursively and ignore nonexistent files

(cd kernel; rm -f kernel.cc)
    - cd kernel: cd means enter a directory (/kernel here); 
    - the parentheses means to open a subshell without disturbing the current process in the shell.

(cd kernel; ln -s ../t0.cc kernel.cc)
    - ln -s ../t0.cc kernel.cc: ln creates a link from file 'kernel.cc' to target file 't0.cc', 
    - "-s": symbolic, which creates a file that do not use sapce on the disk.

(cd kernel; make clean)
    - make: use this makefile to create the executable file 
    - clean:  use this makefile to delete the executable file and all the object files from the directory

g++ -c -MD -std=c++17 -fno-exceptions -fno-rtti -m32 -ffreestanding -nostdlib -g -O3 -Wall -Werror <filename>
    - g++: used to compile c++ files.
    - "-c": Compile and assemble, but do not link
    - "-MD": Output a rule suitable for 'make' describing the dependencies of the main source file and write them to .d file.
    - "-std=c++17": Assume that the input sources are for c++17
    - "-fno-exceptions": 
    - "-m32": generate code for 32 bit environment.
    - "-ffreestanding": 
    - "-nostdlib": Do not use the standard system startup files or libraries when linking. 
    - "-g": turn on debugging
    - "-O3": turns on more optimizations in addition to those in -O2 and -O1
    - "-Wall": Enables all the warnings about constructions that some users consider questionable, and that are easy to avoid. It also enables some language specific warnings.
    - "-Werror": Make all warnings into errors.

gcc -MD -m32 -c <filename>
    - gcc: used to compile c files.
    - "-MD": Output a rule suitable for 'make' describing the dependencies of the main source file and write them to .d file.
    - "-m32": generate code for 32 bit environment.
    - "-c": Compile and assemble, but do not link.

ld -T script.ld -N -m elf_i386 -e start -o kernel init.o snprintf.o u8250.o config.o smp.o debug.o idt.o critical.o libk.o kernel.o  mbr.o machine.o
    - ld: GNU linker that combines a number of object and archive files, relocates their data and ties up symbol references.[3]
    - "-T script.ld": Read linker script
    - "-N": Do not page align data, do not make text readonly
    - "-m elf_i386": set emulation
    - "-e start": set start address at 'start'
    - "-o kernel": set output file as kernel

objcopy -O binary kernel kernel.bin
    - objcopy: copy the contents of an object file to another.
    - "-O binary": Write the output file using binary

dd if=kernel.bin of=kernel.img bs=512 conv=sync > /dev/null 2>&1
    - dd: Copy a file, converting and formatting according to the operands. [4]
    - "if=kernel.bin": read from kernel.bin instead of stdin
    - "of=kernel.img": write to kernel.img instead of stdout
    - "bs=512": read and write up to 512 bytes at a time (default: 512);
    - "conv=sync": convert the file as per the comma separated symbol list
    - "> /dev/null": ignore the output
    - "2>&1": combine stderr and stdout into the stdout stream

---------------------------------------------------------------

Cite your resource:

- '--help' command

- https://wiki.osdev.org/

- https://en.wikipedia.org/

- https://linux.die.net/man/1/

- https://gcc.gnu.org/onlinedocs/gcc/index.html#SEC_Contents
